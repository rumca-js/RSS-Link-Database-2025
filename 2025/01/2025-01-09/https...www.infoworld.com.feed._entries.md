# Source:What senior developers do | InfoWorld, URL:https://www.infoworld.com/feed/, language:en-US

## Researchers build a bridge from C to Rust and memory safety
 - [https://www.infoworld.com/article/3732082/researchers-build-a-bridge-from-c-to-rust-and-memory-safety.html](https://www.infoworld.com/article/3732082/researchers-build-a-bridge-from-c-to-rust-and-memory-safety.html)
 - RSS feed: $source
 - date published: 2025-01-09T21:55:03+00:00

<div id="remove_no_follow">
		<div class="grid grid--cols-10@md grid--cols-8@lg article-column">
					  <div class="col-12 col-10@md col-6@lg col-start-3@lg">
						<div class="article-column__content">
<section class="wp-block-bigbite-multi-title"><div class="container"></div></section>



<p>Memory errors such as out-of-bounds reads and writes and use-after-free bugs have plagued applications for decades, causing problems ranging from minor execution glitches to global security nightmares. The infamous WannaCry, Slammer, and Heartbleed exploits, and the more recent <a href="https://www.csoonline.com/article/3631757/critical-windows-ldap-flaw-could-lead-to-crashed-servers-rce-attacks.html">LDAP Nightmare</a>, for example, were all enabled by buffer overflows.</p>



<p>These memory safety vulnerabilities stem from the use of older programming languages such as <a href="https://www.infoworld.com/article/3402023/why-the-c-programming-language-still-rules.html">C</a> and C++, which lac

## How to use the new Lock object in C# 13
 - [https://www.infoworld.com/article/3632180/how-to-use-the-new-lock-object-in-c-13.html](https://www.infoworld.com/article/3632180/how-to-use-the-new-lock-object-in-c-13.html)
 - RSS feed: $source
 - date published: 2025-01-09T09:00:00+00:00

<div id="remove_no_follow">
		<div class="grid grid--cols-10@md grid--cols-8@lg article-column">
					  <div class="col-12 col-10@md col-6@lg col-start-3@lg">
						<div class="article-column__content">
<section class="wp-block-bigbite-multi-title"><div class="container"></div></section>



<p>The C# programming language has provided support for <a href="https://www.infoworld.com/article/2237276/exploring-thread-synchronization-in-net.html">thread synchronization</a> using the <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/lock">lock keyword</a> since its earliest versions. By using a lock statement, you ensure that only one thread can execute the body of the statement at a time. Any other thread is blocked until the lock is released. </p>



<p>Now C# has an even better, more elegant way to manage thread synchronization, using the new <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.lock?view=net-9.0">Lock class</a> intro

## Working with minimal APIs in .NET
 - [https://www.infoworld.com/article/3635173/working-with-minimal-apis-in-net.html](https://www.infoworld.com/article/3635173/working-with-minimal-apis-in-net.html)
 - RSS feed: $source
 - date published: 2025-01-09T09:00:00+00:00

<div id="remove_no_follow">
		<div class="grid grid--cols-10@md grid--cols-8@lg article-column">
					  <div class="col-12 col-10@md col-6@lg col-start-3@lg">
						<div class="article-column__content">
<section class="wp-block-bigbite-multi-title"><div class="container"></div></section>



<p>If you’re building <a href="https://www.infoworld.com/article/3281046/what-is-cloud-native-the-modern-way-to-develop-software.html">cloud-native</a> applications with <a href="https://www.infoworld.com/article/3445043/what-are-microservices-your-next-software-architecture.html">microservices</a>, they need to be small. You don’t want code that comes with enough dependencies and required libraries to turn something that should be able to scale in milliseconds into megabytes of code. Small services deploy faster, scaling applications quickly, reducing latency, and ensuring a consistent user experience.</p>



<p>Much of the dead weight in <a href="https://www.infoworld.com/article/3269878/what-is

