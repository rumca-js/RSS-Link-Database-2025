[
    {
        "age": null,
        "album": "",
        "author": "/u/Southern-Course-2925",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-07-15T14:45:57.696208+00:00",
        "date_dead_since": null,
        "date_published": "2025-07-15T13:40:17+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>I allocated an RWX (PAGE_EXECUTE_READWRITE) memory region inside LSASS.exe (i tried a RX codecave), then wrote my shellcode there.</p> <p>After that, I tried to execute my shellcode via NtQueueApcThread \u2192 directly pointing to the shellcode. I verified in WinDbg that there are alertable threads inside LSASS.exe.</p> <p>Initially, I assumed Control Flow Guard (CFG) might be blocking this, so I switched to a different technique: NtQueueApcThread \u2192 NtContinue \u2192 shellcode, where I set up a CONTEXT structure with Rip pointing to my shellcode and queued a user APC to NtContinue with this context.</p> <p>However, none of these attempts succeeded \u2014 each time, the target thread would immediately crash into an int 29h (STATUS_STACK_BUFFER_OVERRUN) exception even before reaching NtContinue or my shellcode.</p> <p>Worth mentioning: PPL protection was not present on this LSASS instance.</p> <p>Possible reasons I suspect:</p> <p>Control Flow Guard (CFG) still valida",
        "id": 3170732,
        "language": "",
        "link": "https://www.reddit.com/r/ReverseEngineering/comments/1m0i2ah/code_injection_to_system_process_via_apclsassexe",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 476,
        "source_url": "https://www.reddit.com/r/ReverseEngineering/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Code injection to system process via APC(lsass.exe)",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/Alon1009",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-07-15T17:16:59.647311+00:00",
        "date_dead_since": null,
        "date_published": "2025-07-15T12:19:06+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>I&#39;ve recently published a custom executable packer for Windows `.exe` files made in C, called AlushPacker. It first encrypts and compresses the entire input executable, then, the unpacking routine does the reverse operations and then begins to manual map itself, all within the same process. Essentially it reliably replicates the Windows loader and &quot;becomes&quot; a different executable that is stored encoded in a C buffer.</p> <p>Right now the project has to be compiled from source to pack the file you want, because the builder is still in progress. But I&#39;ve attached a few sample files in case you want to see how it works.</p> <p>This took me a lot of time and research to make. I spent a lot of time mainly by debugging and reverse engineering internal Windows structures and logic. I think I&#39;ve come pretty far, and that you would be interested in this project.</p> <p>Let me know what you think! :)</p> </div><!-- SC_ON --> &#32; submitte",
        "id": 3172093,
        "language": "",
        "link": "https://www.reddit.com/r/ReverseEngineering/comments/1m0ga3i/i_built_a_windows_pe_packer_in_c_with_manual",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 476,
        "source_url": "https://www.reddit.com/r/ReverseEngineering/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "I built a Windows PE packer in C with manual loading, compression / encryption, and TLS/SEH support",
        "vote": 0
    }
]