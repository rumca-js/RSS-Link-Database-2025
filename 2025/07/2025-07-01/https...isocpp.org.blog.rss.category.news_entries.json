[
    {
        "age": null,
        "album": "",
        "author": "Blog Staff",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-07-01T21:52:47.368329+00:00",
        "date_dead_since": null,
        "date_published": "2025-07-01T21:27:49+00:00",
        "description": "<p>\n\t<img alt=\"logo.png\" src=\"https://isocpp.org/files/img/logo.png\" style=\"width: 225px; margin: 10px; float: right;\" />Senders/receivers can be used to introduce concurrency. Lucian Radu Teodorescu describes how to implement senders.</p>\n<blockquote>\n\t<h3>\n\t\t<a href=\"https://accu.org/journals/overload/33/186/teodorescu/\">Writing Senders</a></h3>\n\t<p>\n\t\tby&nbsp;Lucian Radu Teodorescu</p>\n</blockquote>\n<p>\n\tFrom the article:</p>\n<blockquote>\n\t<p>\n\t\tIf people are just using frameworks based on&nbsp;<code>std::execution</code>, they mainly need to care about senders and schedulers. These are user-facing concepts. However, if people want to implement sender-ready abstractions, they also need to consider receivers and operation states &ndash; these are implementer-side concepts. As this article mainly focuses on the implementation of sender abstractions, we need to discuss these two concepts in more detail.</p>\n\t<p>\n\t\tA receiver is defined in P2300 as &ldquo;<em>a callback that supports m",
        "id": 3062941,
        "language": null,
        "link": "https://isocpp.org//blog/2025/07/writing-senders-lucian-radu-teodorescu1",
        "manual_status_code": 0,
        "page_rating": 29,
        "page_rating_contents": 90,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 314,
        "source_url": "https://isocpp.org/blog/rss/category/news",
        "status_code": 0,
        "tags": [],
        "thumbnail": "https://isocpp.org/files/img/logo.png",
        "title": "Writing Senders -- Lucian Radu Teodorescu",
        "vote": 0
    }
]