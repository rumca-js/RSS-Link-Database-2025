[
    {
        "age": null,
        "album": "",
        "author": "/u/NoahKirchner",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-07-28T13:50:04.285275+00:00",
        "date_dead_since": null,
        "date_published": "2025-07-28T08:51:43+00:00",
        "description": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/NoahKirchner\"> /u/NoahKirchner </a> <br/> <span><a href=\"https://kirchware.com/Dynamic-Indirect-Syscalls-via-JOP-or-ROP-in-Rust\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/Malware/comments/1mbb10a/obfuscating_syscall_return_addresses_with_joprop/\">[comments]</a></span>",
        "id": 3216709,
        "language": "en",
        "link": "https://www.reddit.com/r/Malware/comments/1mbb10a/obfuscating_syscall_return_addresses_with_joprop",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 567,
        "source_url": "https://www.reddit.com/r/Malware/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Obfuscating syscall return addresses with JOP/ROP in Rust",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/TrapSlayer0",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-07-28T04:08:55.143999+00:00",
        "date_dead_since": null,
        "date_published": "2025-07-28T01:31:50+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>In the 80s, the very first kernel drivers ran everything, applications, drivers, file systems. But as personal computers branched out from simple hobbyist kits into business machines in the late 80s, a problem emerged: how do you safely let third\u2011party code control hardware without bringing the whole system down?</p> <p>Kernel drivers and core OS data structures all share one contiguous memory map. Unlike user processes where the OS can catch access violations and kill just that process, a kernel fault is often translated into a \u201cstop error\u201d (BSOD). Kernel Drivers simply have nowhere safe to jump back to. You can\u2019t fully bullet\u2011proof a monolithic ring 0 design against every possible memory corruption without fundamentally redesigning the OS.</p> <p>The most common ways a kernel driver can crash is <strong>invalid memory access,</strong> such as dereferencing a null or uninitialized pointer. Or <strong>accessing or freeing memory</strong> that&#39;s al",
        "id": 3214237,
        "language": "en",
        "link": "https://www.reddit.com/r/Malware/comments/1mb3eyh/kernel_driver_development_for_malware_detection",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 567,
        "source_url": "https://www.reddit.com/r/Malware/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Kernel Driver Development for Malware Detection",
        "vote": 0
    }
]