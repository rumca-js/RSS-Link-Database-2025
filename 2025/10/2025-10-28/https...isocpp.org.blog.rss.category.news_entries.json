[
    {
        "age": null,
        "album": "",
        "author": "Blog Staff",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-10-28T21:13:15.714921+00:00",
        "date_dead_since": null,
        "date_published": "2025-10-28T20:05:54+00:00",
        "description": "<p>\n\t<img alt=\"SANDOR_DARGO_ROUND.JPG\" src=\"https://isocpp.org/files/img/SANDOR_DARGO_ROUND.JPG\" style=\"width: 200px; margin: 10px; float: right; height: 204px;\" />In the last post, we built a templated observer framework that let any publisher push strongly-typed messages to its subscribers.<br />\n\tThis time we&rsquo;ll push the design further by trying to let a single publisher handle multiple message types&mdash;and we&rsquo;ll quickly see how that innocent goal invites ambiguity, boilerplate, and some surprising trade-offs.</p>\n<blockquote>\n\t<h3>\n\t\t<a href=\"https://www.sandordargo.com/blog/2025/09/10/observers-part2\">Discovering Observers - Part 2</a></h3>\n\t<p>\n\t\tby Sandor Dargo</p>\n</blockquote>\n<p>\n\tFrom the article:</p>\n<blockquote>\n\t<p>\n\t\tLast week, we took the observer pattern from a very simple example and evolved it into a more flexible, template-based implementation in C++. We ended up with abstracted publishers and subscribers, a templated message type for flexibility, an",
        "id": 3927328,
        "language": "en",
        "link": "https://isocpp.org//blog/2025/10/discovering-observers-part-2-sandor-dargo",
        "manual_status_code": 0,
        "page_rating": 29,
        "page_rating_contents": 90,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 314,
        "source_url": "https://isocpp.org/blog/rss/category/news",
        "status_code": 0,
        "tags": [],
        "thumbnail": "https://isocpp.org/files/img/SANDOR_DARGO_ROUND.JPG",
        "title": "Discovering Observers - Part 2 -- Sandor Dargo",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "Meeting C++",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-10-28T17:02:45.807621+00:00",
        "date_dead_since": null,
        "date_published": "2025-10-28T16:43:21+00:00",
        "description": "<p>\n\tWith today, the <a href=\"https://meetingcpp.com/2025/Schedule.html\">final schedule</a> for <a href=\"https://meetingcpp.com/2025\">Meeting C++ 2025</a> has been published. Tickets for Berlin and online are still available until next week Wednesday!</p>\n<blockquote>\n\t<h2>\n\t\t<a href=\"https://meetingcpp.com/meetingcpp/news/items/The-last-update-to-the-schedule-for-Meeting-Cpp-2025.html\">The last update to the schedule for Meeting C++ 2025</a></h2>\n\t<p>\n\t\tby Jens Weller</p>\n</blockquote>\n<p>\n\tFrom the article:</p>\n<blockquote>\n\t<p>\n\t\tWith release of the static html schedule for the website everything is ready for Meeting C++ 2025!</p>\n\t<p>\n\t\tFor a few years now Meeting C++ offers two schedules: the live schedule is coming from the database, which allows us to make changes during the conference. The other schedule is part of the static website and just a single page powered by the C++ CMS from Meeting C++. Due to the 5th track this year I&#39;ve just had one week before the conference t",
        "id": 3925091,
        "language": "en",
        "link": "https://isocpp.org//blog/2025/10/the-final-schedule-for-meeting-cpp-2025-has-been-published",
        "manual_status_code": 0,
        "page_rating": 29,
        "page_rating_contents": 90,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 314,
        "source_url": "https://isocpp.org/blog/rss/category/news",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "The final schedule for Meeting C++ 2025 has been published",
        "vote": 0
    }
]