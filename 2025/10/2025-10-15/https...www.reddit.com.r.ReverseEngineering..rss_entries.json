[
    {
        "age": null,
        "album": "",
        "author": "/u/neptunym",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-10-15T23:13:18.831983+00:00",
        "date_dead_since": null,
        "date_published": "2025-10-15T22:31:57+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>Nyxelf is a toolkit designed to support both static and dynamic analysis along with disassembly. This is not exactly a new project of mine, but I made some major overhauls on which I would love feedback about. I replaced the simple strace dynamic analysis system with BPFtrace, Valgrind and tcpdump running on a minimal buildroot image, tracing dynamic and memory activity, along with capturing network packets, which is further enhanced with ai-assisted summerisation of the dynamic analysis. I used pyelftools, capstone etc for static analysis, which detects symbols, functions, sections, headers, .rodata variables etc. Finally it disassembles the binary to readable C and x64 intel Assembly with capstone, r2pipe and angry. And this entire thing is presented on the screen with pywebview with a cool one-dark theme. I also made a guide on how to build andreproduce the exact sandbox system if you want to in another markdown file.</p> <p>All sorts of criticism ",
        "id": 3824182,
        "language": "",
        "link": "https://www.reddit.com/r/ReverseEngineering/comments/1o7pbu1/nyxelf_created_a_dynamic_analysis_toolkit_to_pry",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 476,
        "source_url": "https://www.reddit.com/r/ReverseEngineering/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Nyxelf, created a dynamic analysis toolkit to pry open ELF Binaries.",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/asherdl02",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-10-15T17:01:20.891526+00:00",
        "date_dead_since": null,
        "date_published": "2025-10-15T16:40:02+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>An approach to reversing IoT and OT malware written in Go using a hybrid toolkit that blends AI with traditional analysis methods using #Radare2 , #Ghidra, and #BinaryNinja. By Asher Davila &amp; Chris Navarrete</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/asherdl02\"> /u/asherdl02 </a> <br/> <span><a href=\"https://youtu.be/TtPicirB6G4?si=4bCkY3wNZrrOG8Wb\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/ReverseEngineering/comments/1o7g31a/go_malware_meets_iot_def_con_33/\">[comments]</a></span>",
        "id": 3821121,
        "language": "",
        "link": "https://www.reddit.com/r/ReverseEngineering/comments/1o7g31a/go_malware_meets_iot_def_con_33",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 476,
        "source_url": "https://www.reddit.com/r/ReverseEngineering/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Go Malware meets IoT: DEF CON 33",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/SUmidcyber",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-10-15T14:29:43.335104+00:00",
        "date_dead_since": null,
        "date_published": "2025-10-15T14:22:54+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>I just published a new YARA tutorial focusing on advanced detection techniques! \ud83d\ude80</p> <p><strong>What&#39;s covered:</strong><br/> \u2022 Hex pattern writing (MZ header, magic numbers)<br/> \u2022 File size analysis for suspicious files<br/> \u2022 Hash-based detection methods<br/> \u2022 Real-world combination rules<br/> \u2022 Performance optimization tips</p> <p><strong>Perfect for:</strong></p> <ul> <li>Malware analysts</li> <li>Threat hunters</li> <li>DFIR professionals</li> <li>Security researchers</li> </ul> <p><strong>Video includes practical examples you can use immediately.</strong></p> <p><strong><a href=\"https://youtu.be/4m818udv42g?si=NUHwWorJ%5C_UNjBz6V\">https://youtu.be/4m818udv42g?si=NUHwWorJ\\_UNjBz6V</a></strong></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/SUmidcyber\"> /u/SUmidcyber </a> <br/> <span><a href=\"https://youtu.be/4m818udv42g?si=NUHwWorJ_UNjBz6V\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.co",
        "id": 3819645,
        "language": "",
        "link": "https://www.reddit.com/r/ReverseEngineering/comments/1o7cdtb/yara_deep_dive_hex_patterns_file_size_hash",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 476,
        "source_url": "https://www.reddit.com/r/ReverseEngineering/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "YARA Deep Dive: Hex Patterns, File Size & Hash Detection",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/AndrewMD5",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-10-15T13:09:35.387251+00:00",
        "date_dead_since": null,
        "date_published": "2025-10-15T12:56:24+00:00",
        "description": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/AndrewMD5\"> /u/AndrewMD5 </a> <br/> <span><a href=\"https://andrews.substack.com/p/reverse-engineering-iwork\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/ReverseEngineering/comments/1o7a8sx/reverse_engineering_iwork_so_you_dont_have_to/\">[comments]</a></span>",
        "id": 3818920,
        "language": "",
        "link": "https://www.reddit.com/r/ReverseEngineering/comments/1o7a8sx/reverse_engineering_iwork_so_you_dont_have_to",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 476,
        "source_url": "https://www.reddit.com/r/ReverseEngineering/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Reverse Engineering iWork (So You Don't Have To)",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/Fatmike-Reddit",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-10-15T05:58:55.587164+00:00",
        "date_dead_since": null,
        "date_published": "2025-10-15T05:51:24+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>The techniques used are probably already familiar to most people, but maybe they\u2019ll still be interesting for some.<br/> The code shows how to launch and control a target windows process to apply patches directly to the process&#39;s memory or CPU registers at a chosen time.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Fatmike-Reddit\"> /u/Fatmike-Reddit </a> <br/> <span><a href=\"https://github.com/Fatmike-GH/Loader\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/ReverseEngineering/comments/1o72zk1/github_fatmikeghloader_a_windows_executable/\">[comments]</a></span>",
        "id": 3816425,
        "language": "",
        "link": "https://www.reddit.com/r/ReverseEngineering/comments/1o72zk1/github_fatmikeghloader_a_windows_executable",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 476,
        "source_url": "https://www.reddit.com/r/ReverseEngineering/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "GitHub - Fatmike-GH/Loader: A Windows executable 'loader' (in-memory patcher) for x86 and x64 targets, designed for controlled in-memory patching of executables (PE images).",
        "vote": 0
    }
]