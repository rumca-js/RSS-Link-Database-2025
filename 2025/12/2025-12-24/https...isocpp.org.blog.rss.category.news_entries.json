[
    {
        "age": null,
        "album": "",
        "author": "Giovanni Dicanio",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-12-24T22:30:07.011705+00:00",
        "date_dead_since": null,
        "date_published": "2025-12-24T22:13:31+00:00",
        "description": "<p>\n\tWith ASCII, it&#39;s very simple to find the next character in a string: you can just increment an index (i++) or char pointer (pch++). But what happens when you have Unicode strings to process?</p>\n<blockquote>\n\t<h3>\n\t\t<a href=\"https://giodicanio.com/2025/11/03/finding-the-next-unicode-code-point-in-strings-utf-8-vs-utf-16/\">Finding the Next Unicode Code Point in Strings: UTF-8 vs. UTF-16</a></h3>\n</blockquote>\n<blockquote>\n\t<p>\n\t\tby Giovanni Dicanio</p>\n</blockquote>\n<p>\n\tFrom the article:</p>\n<blockquote>\n\t<p>\n\t\tBoth UTF-16 and UTF-8 are variable-length encodings. In particular, UTF-8 encodes each valid Unicode code point using one to four 8-bit byte units. On the other hand, UTF-16 is somewhat simpler: In fact, Unicode code points are encoded in UTF-16 using just one or two 16-bit code units.</p>\n\t<p>\n\t\t(...) The functions have the following prototypes:</p>\n</blockquote>\n<blockquote>\n\t<pre class=\"prettyprint lang-cpp\">\n// Returns the next Unicode code point and number of byte",
        "id": 4401031,
        "language": "en",
        "link": "https://isocpp.org//blog/2025/12/finding-the-next-code-point-in-unicode-strings-giovanni-dicanio",
        "manual_status_code": 0,
        "page_rating": 29,
        "page_rating_contents": 90,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 314,
        "source_url": "https://isocpp.org/blog/rss/category/news",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Finding the Next Code Point in Unicode Strings -- Giovanni Dicanio",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "Blog Staff",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-12-24T22:30:07.324417+00:00",
        "date_dead_since": null,
        "date_published": "2025-12-24T17:12:04+00:00",
        "description": "<p>\n\t<img alt=\"acmqueue_logo.gif\" src=\"https://isocpp.org/files/img/acmqueue_logo.gif\" style=\"width: 160px; margin: 10px; float: right;\" />Memory-safety vulnerabilities remain one of the most persistent and costly risks in large-scale C++ systems, even in well-tested production code. This article explores how hardening the C++ Standard Library&mdash;specifically LLVM&rsquo;s libc++&mdash;can deliver meaningful security and reliability gains at massive scale with minimal performance overhead.</p>\n<blockquote>\n\t<h3>\n\t\t<a href=\"https://queue.acm.org/detail.cfm?id=3773097\">Practical Security in Production: Hardening the C++ Standard Library at massive scale</a></h3>\n\t<p>\n\t\tby Louis Dionne, Alex Rebert, Max Shavrick, and Konstantin Varlamov</p>\n</blockquote>\n<p>\n\tFrom the article:</p>\n<blockquote>\n\t<p>\n\t\tOver the past few years there has been a lot of talk about memory-safety vulnerabilities, and rightly so&mdash;attackers continue to take advantage of them to achieve their objectives. Asi",
        "id": 4401032,
        "language": "en",
        "link": "https://isocpp.org//blog/2025/12/hardening-the-cpp-standard-library-at-massive-scale-dionne-rebert-shavrick",
        "manual_status_code": 0,
        "page_rating": 29,
        "page_rating_contents": 90,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 314,
        "source_url": "https://isocpp.org/blog/rss/category/news",
        "status_code": 0,
        "tags": [],
        "thumbnail": "https://isocpp.org/files/img/acmqueue_logo.gif",
        "title": "Hardening the C++ Standard Library at massive scale -- Dionne, Rebert, Shavrick, and Varlamov",
        "vote": 0
    }
]