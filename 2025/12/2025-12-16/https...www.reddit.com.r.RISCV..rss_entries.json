[
    {
        "age": null,
        "album": "",
        "author": "/u/Kongen_xD",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-12-16T22:43:10.724283+00:00",
        "date_dead_since": null,
        "date_published": "2025-12-16T21:50:09+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>Hi all,</p> <p>In my system I have a memory mapped Clint which is used to setup timer interrupts in machine mode.</p> <p>Now what I want is to setup the timer interrupts every x clint cycles.</p> <p>What I do is that when the timer interrupts happens, then inside the timer interrupt handler, I setup the next interrupt using the mtimecmp register. What I have noticed is that the write to mtimecmp can occur after returning from the interrupt handler, I.e. mret.</p> <p>If I place a fence o, o after writing the mtimecmp, then it does not happen.</p> <p>Now the question is, what is the correct way to do the fence.</p> <p>The sequence I think I need is the following:</p> <ol> <li>Write mtimecmp</li> <li>Fence &lt;- ensures the write happens before mret</li> <li>Mret</li> </ol> <p>But, what is important is just that the write finishes before mret, not other memory operation, so I\u2019m not sure that fence o, o is the correct type of fence. I\u2019m probably misunders",
        "id": 4338388,
        "language": "en",
        "link": "https://www.reddit.com/r/RISCV/comments/1poepta/correct_fencing_for_mtimecmp_in_interrupt_handler",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 471,
        "source_url": "https://www.reddit.com/r/RISCV/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Correct fencing for mtimecmp in interrupt handler",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/I00I-SqAR",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-12-16T04:10:56.050948+00:00",
        "date_dead_since": null,
        "date_published": "2025-12-16T03:14:16+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p><strong>SAN JOSE, Calif.</strong> <strong>\u2014 Dec 16, 2025 \u2014</strong> S2C, MachineWare, and Andes Technology today announced a collaborative co-emulation solution designed to address the increasing complexity of RISC-V based chip design. The solution integrates MachineWare\u2019s SIM-V virtual platform, S2C\u2019s Genesis Architect and Prodigy FPGA Prototyping Systems, and Andes\u2019high-performance AX46MPV RISC-V CPU core, providing a unified environment for hardware and software co-verification.</p> <p>As RISC-V designs move toward high-performance, multi-core, and highly customized architectures, pre-silicon software development and system validation have become more challenging. This co-emulation solution supports a \u201cshift-left\u201d verification approach, allowing hardware and software teams to work in parallel. The result is reduced development time and lower project risk.</p> <p>\u2026</p> <p><a href=\"https://www.andestech.com/en/2025/12/16/s2c-machineware-and-andes-int",
        "id": 4330559,
        "language": "en",
        "link": "https://www.reddit.com/r/RISCV/comments/1pnrdvw/s2c_machineware_and_andes_introduce_riscv",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 471,
        "source_url": "https://www.reddit.com/r/RISCV/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "S2C, MachineWare, and Andes Introduce RISC-V Co-Emulation Solution to Accelerate Chip Development",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/Evil_Gamer_01",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-12-16T03:07:59.918155+00:00",
        "date_dead_since": null,
        "date_published": "2025-12-16T02:35:15+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>Hi guys. I&#39;m new with embedded development and because I did some research into RISC-V I decided to give a try to VisionFive 2. Now I&#39;m reading about the boot sequence and for what I could catch about this is a summary.</p> <p>First JH7100 has a flag called SCFG_boot_mode to debug the SoC but inside VF2 is dissabled. and PAD_GPIO[63] is hardwired to 1 to always use the bootROM to decide the booting device.</p> <p>The ROM is on address 0x1840_0000 to 0x1840_7FFF (fixed size of 32KiB)</p> <p>However this code is copied into a small SRAM at the range of 0x1800_0000 - 0x1801_FFFF, intRAM0</p> <p>bootROM then it only search available devices of its boot options (QSPI and UART for VF2 however the SoC allows 8 different ways) and resolve from switches selection.</p> <p>Then will read from a NOR Flash device addressable at 0x2000_0000 a portion of the code with the DDR init and copy into another small SRAM at address 0x1808_0000 - 0x1809_FFFF, intRAM1",
        "id": 4330317,
        "language": "en",
        "link": "https://www.reddit.com/r/RISCV/comments/1pnqktx/about_visionfive_2_boot_sequence",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 471,
        "source_url": "https://www.reddit.com/r/RISCV/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "About VisionFive 2 boot sequence",
        "vote": 0
    }
]