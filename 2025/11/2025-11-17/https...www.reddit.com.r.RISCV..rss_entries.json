[
    {
        "age": null,
        "album": "",
        "author": "/u/superkoning",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-11-17T13:05:01.443071+00:00",
        "date_dead_since": null,
        "date_published": "2025-11-17T12:45:40+00:00",
        "description": "<table> <tr><td> <a href=\"https://www.reddit.com/r/RISCV/comments/1ozfbgo/chinas_chip_leaders_bank_on_ai_riscv_as_industrys/\"> <img src=\"https://external-preview.redd.it/Byjsm5GHuYYK2d6KL03mJMH7i34vH4be8af8I5Ip4xQ.jpeg?width=640&amp;crop=smart&amp;auto=webp&amp;s=784889042d9c31c93f890b035682282d47ea1d29\" alt=\"China\u2019s chip leaders bank on AI, RISC-V as industry\u2019s growth engines\" title=\"China\u2019s chip leaders bank on AI, RISC-V as industry\u2019s growth engines\" /> </a> </td><td> <!-- SC_OFF --><div class=\"md\"><p>Good news about RISC-V! At least, if there are going to be great performing CPU&#39;s for us at home.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/superkoning\"> /u/superkoning </a> <br/> <span><a href=\"https://www.reddit.com/r/hardware/comments/1ozayxa/chinas_chip_leaders_bank_on_ai_riscv_as_industrys/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/RISCV/comments/1ozfbgo/chinas_chip_leaders_bank_on_ai_riscv_as_industrys/\">[co",
        "id": 4089717,
        "language": "en",
        "link": "https://www.reddit.com/r/RISCV/comments/1ozfbgo/chinas_chip_leaders_bank_on_ai_riscv_as_industrys",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 86,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 471,
        "source_url": "https://www.reddit.com/r/RISCV/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": "https://external-preview.redd.it/Byjsm5GHuYYK2d6KL03mJMH7i34vH4be8af8I5Ip4xQ.jpeg?width=640&crop=smart&auto=webp&s=784889042d9c31c93f890b035682282d47ea1d29",
        "title": "China\u2019s chip leaders bank on AI, RISC-V as industry\u2019s growth engines",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/krakenlake",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-11-17T09:00:28.669409+00:00",
        "date_dead_since": null,
        "date_published": "2025-11-17T08:25:04+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>While hand-writing assembly (and aiming for shortest code), I came up with this (probably very old) trick to shorten function epilogues. I define this:</p> <pre><code># for function epilogue optimisation (shorter code in total) pop_s1_s0_ra_ret: ld s1, 0(sp) # get s1 back addi sp, sp, 8 pop_s0_ra_ret: ld s0, 0(sp) # get s0 back addi sp, sp, 8 pop_ra_ret: ld ra, 0(sp) # get ra back addi sp, sp, 8 ret #define PUSH_RA jal gp, push_ra #define PUSH_S0_RA jal gp, push_s0_ra #define PUSH_S1_S0_RA jal gp, push_s1_s0_ra #define POP_RA_RET j pop_ra_ret #define POP_S0_RA_RET j pop_s0_ra_ret #define POP_S1_S0_RA_RET j pop_s1_s0_ra_ret </code></pre> <p>Then, inside functions, I do this:</p> <pre><code>some_function1: PUSH_S0_RA # put s0 and ra on stack &lt; do something useful, using s0 and ra&gt; POP_S0_RA_RET # restore regs and jump to ra some_function2: PUSH_S1_S0_RA # put s1, s0 and ra on stack &lt; do something useful, using s1, s0 and ra&gt; POP_S1_S0_RA_RET",
        "id": 4088138,
        "language": "en",
        "link": "https://www.reddit.com/r/RISCV/comments/1ozayim/manual_function_prologue_shortening_trick",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 471,
        "source_url": "https://www.reddit.com/r/RISCV/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Manual function prologue shortening trick?",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/I00I-SqAR",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-11-17T05:57:41.845347+00:00",
        "date_dead_since": null,
        "date_published": "2025-11-17T05:49:38+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p><a href=\"https://github.com/Wren6991/Hazard3/releases/tag/v1.1\">https://github.com/Wren6991/Hazard3/releases/tag/v1.1</a></p> <p><a href=\"https://x.com/wren6991/status/1990216644891688980\">https://x.com/wren6991/status/1990216644891688980</a></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/I00I-SqAR\"> /u/I00I-SqAR </a> <br/> <span><a href=\"https://www.reddit.com/r/RISCV/comments/1oz8giu/new_stable_release_of_hazard3_available/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/RISCV/comments/1oz8giu/new_stable_release_of_hazard3_available/\">[comments]</a></span>",
        "id": 4087353,
        "language": "en",
        "link": "https://www.reddit.com/r/RISCV/comments/1oz8giu/new_stable_release_of_hazard3_available",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 471,
        "source_url": "https://www.reddit.com/r/RISCV/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "New stable release of Hazard3 available",
        "vote": 0
    },
    {
        "age": null,
        "album": "",
        "author": "/u/Full_Duplex_37",
        "bookmarked": false,
        "comments": [],
        "date_created": "2025-11-17T01:54:52.954750+00:00",
        "date_dead_since": null,
        "date_published": "2025-11-17T00:54:08+00:00",
        "description": "<!-- SC_OFF --><div class=\"md\"><p>As I understand, RISC-V doesn&#39;t really care that much about efficient immediate register loads. AFAIK only way on standard ISA to make immediate load is through sequence of two instructions: one for bottom 20 bits, and second one for upper 12.</p> <p>It gets weirder with 64-bit immediate register load: naive solution would mean 5-ish instructions to build 64-bit value in similar way.</p> <p>There is a pseudo-instruction in assembler and compiler can presumably shorten/optimize this if the value falls into specific ranges.</p> <p>Why is that ? Are immediate loads so completelly unimportant ? Or there might be better, more elegant way to do it ? PC-relative memory load comes to mind, but that complicates things as one has to have convenient spot from which to load. And another data stream that needs separate caching.</p> <p>Unless that data for example, is immediatelly before the function that one has just called. But even this seems suboptimal from",
        "id": 4086415,
        "language": "en",
        "link": "https://www.reddit.com/r/RISCV/comments/1oz2ivn/immediate_loads_on_riscv",
        "manual_status_code": 0,
        "page_rating": 27,
        "page_rating_contents": 85,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 471,
        "source_url": "https://www.reddit.com/r/RISCV/.rss",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Immediate loads on RISC-V ?",
        "vote": 0
    }
]