[
    {
        "age": null,
        "album": "",
        "author": null,
        "bookmarked": false,
        "comments": [],
        "date_dead_since": null,
        "date_published": "2025-04-09T20:02:18+00:00",
        "description": "<p>\n\t<img alt=\"1.png\" src=\"https://isocpp.org/files/img/1.png\" style=\"width: 250px; margin: 10px; float: right; height: 250px;\" />C++26 will introduce senders/receivers. Lucian Radu Teodorescu demonstrates how to use them to write multithreaded code.</p>\n<blockquote>\n\t<h3>\n\t\t<a href=\"https://accu.org/journals/overload/33/185/teodorescu/\">Using Senders/Receivers</a></h3>\n\t<p>\n\t\tby Lucian Radu Teodorescu</p>\n</blockquote>\n<p>\n\tFrom the article:</p>\n<blockquote>\n\t<p>\n\t\tThis is a follow-up to the article in the previous issue of&nbsp;<em>Overload</em>, which introduced the upcoming C++26 senders/receivers framework [<a href=\"https://accu.org/journals/overload/33/185/teodorescu/#_idTextAnchor008\">WG21Exec</a>]. While the previous article focused on presenting the main concepts and outlining what will be standardized, this article demonstrates how to use the framework to build concurrent applications.</p>\n\t<p>\n\t\tThe goal is to showcase examples that are closer to real-world software rather",
        "id": 2521349,
        "language": null,
        "link": "https://isocpp.org//blog/2025/04/using-senders-receivers-lucian-radu-teodorescu",
        "manual_status_code": 0,
        "page_rating": 29,
        "page_rating_contents": 90,
        "page_rating_visits": 0,
        "page_rating_votes": 0,
        "permanent": false,
        "source__id": 314,
        "source_url": "https://isocpp.org/blog/rss/category/news",
        "status_code": 0,
        "tags": [],
        "thumbnail": null,
        "title": "Using Senders/Receivers -- Lucian Radu Teodorescu",
        "vote": 0
    }
]